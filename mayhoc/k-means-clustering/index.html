<!DOCTYPE html>
<html lang="en-us"><head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="clustering">
  <meta name="author" content="Doan Nguyen" />
  <meta property="title" content="Doan Nguyen" />

  <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.1.1/css/bootstrap.min.css" integrity="sha384-WskhaSGFgHYWDcbwN70/dfYBj47jz9qbsMId/iRN3ewGhXQFZCSftd1LZCfmhktB" crossorigin="anonymous">
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script src="https://code.jquery.com/jquery-3.3.1.slim.min.js" integrity="sha384-q8i/X+965DzO0rT7abK41JStQIAqVgRVzpbzo5smXKp4YfRvH+8abtTE1Pi6jizo" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.14.3/umd/popper.min.js" integrity="sha384-ZMP7rVo3mIykV+2+9J3UJ46jBk0WLaUAdn689aCwoqbBJiSnjAK/l8WvCWPIPm49" crossorigin="anonymous"></script>
  <script src="https://stackpath.bootstrapcdn.com/bootstrap/4.1.1/js/bootstrap.min.js" integrity="sha384-smHYKdLADwkXOn1EmN1qk/HfnUcbVRZyYmZ4qpPea6sjB/pTJ0euyQp0Mk8ck+5T" crossorigin="anonymous"></script>
  <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.0.13/css/all.css" integrity="sha384-DNOHZ68U8hZfKXOrtjWvjxusGo9WQnrNx2sqG0tfsghAvtVlRW3tvkXWZh58N9jp" crossorigin="anonymous">
  <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS_CHTML"></script>
  <!-- plugins -->
  
  <link rel="stylesheet" href="https://doannguyentrong.github.io/plugins/style.css ">
  
  <!--Favicon-->
  
  
  <link rel="icon" href="https://doannguyentrong.github.io/images/favicon.png " type="image/x-icon">
  <title>k-Means Clustering </title>
</head><body><header> 
  
  <nav class="navbar navbar-expand-md navbar-light bg-light fixed-top">
      <div class="container-fluid">
          
          <div class="navbar-header">
              <a class="navbar-brand" href="https://doannguyentrong.github.io/"><img src="https://doannguyentrong.github.io/images/author.png" alt="Doan Nguyen"></a>
          </div>
            
            <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarResponsive">
              <span class="navbar-toggler-icon"></span>
          </button>

          <div class="collapse navbar-collapse" id="navbarResponsive">
              
              <ul class="navbar-nav ml-auto">
                
                
                
                <li class="nav-item">
                  <a class="nav-link" href="https://doannguyentrong.github.io/">Home</a>
                </li>
                
                
                
                <li class="nav-item">
                  <a class="nav-link" href="https://doannguyentrong.github.io/about">About</a>
                </li>
                
                
                
                <li class="nav-item">
                  <a class="nav-link" href="https://doannguyentrong.github.io/posts">Posts</a>
                </li>
                
                
              </ul>
          </div>

      </div>
  </nav>
</header>


<div class="container-fluid padding" style="padding-top: 7em;">
  <div class="row welcome">
      <div class="col-12">
          
          <h3 class="font-tertiary mb-5 text-center">k-Means Clustering</h3>
          <div class=" align-center">
            <img src="https://doannguyentrong.github.io/images/author.png" alt="post-thumb" class="img-fluid rounded float-left mr-5 mb-4">
          <p class="font-secondary">Published on Sep 17, 2019 by <span class="text-primary">Doan Nguyen</span></p>
          </div>
          <div class="content text-justify post-text">
            <img class="img-fluid" style="max-width: 100%; height: auto;"  >
            <h2 id="vài-dòng-giới-thiệu-về-thuật-toán">Vài dòng giới thiệu về thuật toán</h2>
<p>| k-Means Clustering là một trong những thuật toán đơn giản và nổi tiếng
nhất của làng Machine Learning. Nó là phương pháp tuy đơn giản nhưng
đặc biệt hiệu quả trong bài toán Unsupervised Learning, khi mà dữ liệu
của bạn chưa được phân loại (unlabeled). Mục tiêu của thuật toán này
là chia nhỏ data của bạn thành k groups dựa trên features được cung
cấp.. Các điểm dữ liệu được xếp vào trong từng nhóm dựa trên sự giống
nhau về đặc điểm nhận dạng .</p>
<h2 id="ứng-dụng-trong-thực-tế">Ứng dụng trong thực tế</h2>
<p>| Vì khả năng cơ bản của k-Means Clustering là chia nhỏ dữ liệu ban đầu
thành các nhóm nhỏ, tất cả hoạt động dựa trên thuật toán mà không yêu
cầu bất kì kiến thức của người sử dụng về dữ liệu đã được thu thập(to</p>
<ul>
<li>nhỏ, xấu - đẹp, méo - tròn). Nó có thể được sử dụng để xác nhận các
giả thiết về việc nên phân chia làm bao nhiêu nhóm, là những nhóm nào,
khi mà lượng dữ liệu thu được lớn và phức tạp. Khi mà 2 thông số trên
được xác định, bất kì một sample mới sẽ đễ dàng được gán nhãn vào vị
trí chính xác.
| Đây là một thuật toán linh hoạt có thể được ứng dụng vào bất kì quy
trình <strong>phân loại và chia nhóm</strong>. Một vài ví dụ có thể kể đến sau đây:</li>
</ul>
<p>#. Trong giao dich ngân hàng, việc phân loại dữ liệu khách hàng là đặc
biệt quan trọng, thường được dựa vào đó để đưa ra các chính sách
chung cho toàn hệ thống hay là có những chính sách chăm sóc đến từng
khách hàng. Một vài cách phân loại dựa trên hành vi người dùng như
sau:</p>
<ul>
<li>
<p>Phân loại dựa trên lịch sử thanh toán (chi tiêu)</p>
</li>
<li>
<p>Phân loại dựa trên hoạt động trên ứng dụng di động, trên website,
hay trên nền tảng ATM</p>
</li>
<li>
<p>Định nghĩa tính cách cá nhân khách hàng dựa trên mối quan tâm của
họ (thông qua lịch sử mua sắm)</p>
</li>
<li>
<p>Tạo profile của khách hàng dựa trên dữ liệu theo dõi hoạt động</p>
</li>
</ul>
<p>#. Phân loại sáng chế của cục sở hữu khoa học kĩ thuật:</p>
<ul>
<li>
<p>Nhóm các sáng chế dựa trên hoạt động kinh doanh</p>
</li>
<li>
<p>Nhóm các sáng chế dựa trên khối ngành sản suất</p>
</li>
</ul>
<p>#. Phân loại cảm biến theo chức năng:</p>
<ul>
<li>
<p>Phương pháp phát hiện hoạt động trong nhóm cảm biến chuyển động</p>
</li>
<li>
<p>Chia nhóm ảnh</p>
</li>
<li>
<p>Phân loại file audio</p>
</li>
<li>
<p>Chia nhóm trong theo dõi sức khỏe</p>
</li>
</ul>
<p>Đặc biệt, việc theo dõi sự thay đổi của những điểm dữ liệu bị theo dõi
(một số cá nhân trong dữ liệu khách hàng của ngân hàng) có thể được sử
dụng để theo dõi xu hướng hoạt động. Điều này thường được sử dụng nhiều
trong theo dõi hoạt động mua sắm, góp phần giúp cho các tập đoàn lớn như
Nike, Zara, Uniqlo&hellip; nắm bắt được người dùng và đưa ra những chính sách
góp phần nâng cao doanh số cũng như thúc đẩy hoạt động mua sắm.</p>
<h2 id="lí-thuyết">Lí thuyết</h2>
<p>| Bắt đầu bằng một ví dụ đơn giản, trong một lớp có 50 học sinh, chúng
ta cần chia thành 3 nhóm dựa trên chiều cao của các cá nhân trong lớp.
Có thể tạm gọi là &ldquo;Cao&rdquo;, &ldquo;Trung Bình&rdquo;, và &ldquo;Thấp&rdquo;. Việc dán nhãn như
trên chỉ mang tính minh họa và hoàn toàn không ảnh hưởng đến kết quả
của bài toán. Như vậy chúng ta có một tập dữ liệu \( \mathbf{x}_i, i=1 \cdots 50 \) là 50 giá trị chiều cao của các
thành viên trong lớp.
| Như đã nói ở trên, chúng ta muốn chia lớp thành 3 nhóm, do đó chúng ta
có :math:\(\mathbf{c}_j, j = 1 \cdots 3\) là kí hiệu 3 điểm trung tâm
của mỗi nhóm. :math:\(\mathbf{c}_j\) là một giá trị về chiều cao (mét)
và những cá nhân trong lớp có chiều cao gần với :math:\(\mathbf{c}_j\)
sẽ được xếp vào nhóm \(j\). Tôi để các giá trị
\(\mathbf{c}_j\), \(\mathbf{x}_i\) in đậm thể hiện đó là
vector vì trong ví dụ này, chúng ta chỉ có một tham số được đo lường
đó là chiều cao, nhưng để không mất tính tổng quát,
\(\mathbf{c}_j\) và \(\mathbf{x}_i\) có thể chứa thêm nhiều
tham số khác, như ngày tháng nắm sinh, cân nặng, &hellip;
|  Việc tiếp theo là định nghĩa khoảng cách về chiều cao giữa một thành
viên bất kì \(\mathbf{x}_i\) đến điểm trung tâm của nhóm
\(\mathbf{c}_j\). Chúng ta có định nghĩa:</p>
<p>\[ d_j\left( {{{\bf{x}}_i},{{\bf{c}}_j}} \right) = \left| {{{\bf{x}}_i} - {{\bf{c}}_j}} \right|_2^2 \]</p>
<p>là hàm khoảng cách giữa hai điểm này.</p>
<ul>
<li>
<p>\(d_j\left( {{{\bf{x}}_i},{{\bf{c}}_j}} \right)\) là kí hiệu
khoảng cách (lấy chữ cái đầu trong &ldquo;distance&rdquo;) giữa hai điểm
\(\mathbf{c}_i\) và \(\mathbf{x}_i\).</p>
</li>
<li>
<p>\(\left| {\cdots} \right|_2^2\) là bình phương của hàm
\(L^2-norm\) (hay còn được gọi là vector norm)</p>
</li>
</ul>
<p>Giải thích một chút về hàm \(L^2-norm\) này. Công thức toán học
của nó như sau:</p>
<p>\[ \left| {{{\bf{x}}_i} - {{\bf{c}}_i}} \right|<em>2} = \sqrt{\sum\limits</em>{k = 1}^n {{{\left| {{x_k} - {c_k}} \right|}^2}} \]</p>
<p>với vector
\({{\bf{x}}_i} = \left\langle {{x_1},{x_2},&hellip;,{x_k},&hellip;,{x_n}} \right\rangle\)
và
\({{\bf{c}}_i} = \left\langle {{c_1},{c_2},&hellip;,{c_k},&hellip;,{c_n}} \right\rangle\).
Trong ví dụ này, \(\mathbf{c}_j\) và \(\mathbf{x}<em>i\) chỉ có 1
tham số duy nhất nên giả sử ta có: \(\mathbf{x}</em>{34} = 1.32m\) thể
hiện thành viên thứ 34 trong lớp có chiều cao \(1.32m\), và
\(\mathbf{c}_2 = 1.30m\) thể hiện nhóm \(j=2\) có giá trị
trung tâm là \(1.30m\), chúng ta có thể tính ra được giá trị của
hàm khoảng cách:</p>
<p>\[ d_j\left( {{{\bf{x}}_i},{{\bf{c}}_j}} \right) = {\left( {\sqrt {{{\left( {1.32 - 1.30} \right)}^2}} } \right)^2} = {\left( {0.02} \right)^2} = 0.004\]</p>
<p>(Các bạn đừng quên là chúng ta đang tính bình phương nhé).
Chúng ta có 3 giá trị của 3 nhóm khi \(j=1 \cdots 3\), do đó hàm
tổng khoảng cách từ 1 điểm \(\mathbf{x}_i\) đến cả 3 điểm
\(\mathbf{c}_i\) là:</p>
<p>\[ \sum\limits_{j = 1}^k {d\left( {{{\bf{x}}_i},{{\bf{c}}<em>j}} \right)}  = \sum\limits</em>{j = 1}^k {\left| {{{\bf{x}}_i} - {{\bf{c}}_j}} \right|_2^2}\]</p>
<p>ở đây \(k=3\) là số clusters, như đã được định nghĩa ở trên.
Đến đây, chúng ta đã tính được khoảng cách từ 1 điểm
\(\mathbf{x}_i\), nhưng vì chúng ta có tất cả 50 thành viên trong
lớp, do đó, hàm khoảng cách cần phải nâng cấp lên 1 lần nữa.</p>
<p>\[ \sum\limits_{i = 1}^m {\sum\limits_{j = 1}^k {d\left( {{{\bf{x}}<em>i},{{\bf{c}}<em>j}} \right)} }  = \sum\limits</em>{i = 1}^m {\sum\limits</em>{j = 1}^k {\left| {{{\bf{x}}_i} - {{\bf{c}}_j}} \right|_2^2} }\]</p>
<p>\(m=50\) là số sample trong data hay số thành viên trong lớp.</p>
<p>Đến đây, chúng ta đã có một hàm có thể ước lượng được ưu nhược điểm
của \(\mathbf{c}_j\). Càng chọn \(\mathbf{c}_j\) sao cho hàm
trên có giá trị càng nhỏ, thuật toán càng tốt hơn. Khi mà giá trị của
\(\mathbf{x}_i\) là cố định thì <strong>PHƯƠNG PHÁP CHỌN</strong>
\(\mathbf{c}_j\) là trung tâm của thuật toán k-Means Clustering.
Bây giờ, ta có thể đặt:</p>
<p>\[ J = \sum\limits_{i = 1}^m {\sum\limits_{j = 1}^k {d\left( {{{\bf{x}}<em>i},{{\bf{c}}<em>j}} \right)} }  = \sum\limits</em>{i = 1}^m {\sum\limits</em>{j = 1}^k {\left| {{{\bf{x}}_i} - {{\bf{c}}_j}} \right|_2^2} }\]</p>
<p>là hàm mục tiêu (objective function) hay hàm phí tổn (cost function)
cho bài toán.
Và thuật toán k-Means Clustering đi tìm giá trị cực tiểu:</p>
<p>\[ {J_{\min }} = \arg \mathop {\min }\limits_c \sum\limits_{i = 1}^m {\sum\limits_{j = 1}^k {d\left( {{{\bf{x}}_i},{{\bf{c}}_j}} \right)} }\]</p>
<h2 id="thuật-toán">Thuật toán</h2>
<p>Bây giờ là lúc chúng ta cùng nhau tìm hiểu về quy luật để từ những giá
trị \(\mathbf{c}_j\) được chọn ngẫu nhiên, chúng ta có thể đi đến
giá trị mong muốn đảm bảo việc phân nhóm thành công. Sơ đồ thuật toán
như sau:</p>
<p>#. Input: \(k\)- số cluster, \(\mathbf{x}_i, i=1 \cdots 50\)-
data</p>
<p>#. Khởi tạo: Đặt \(\mathbf{c}_j, j = 1 \cdots 3\) tại các vị trí bất
kì</p>
<p>#. Lặp lại đến khi hội tụ:</p>
<ul>
<li>
<p>Với mỗi điểm \(\mathbf{x}_i\):</p>
<ul>
<li>
<p>Tìm điểm trung tâm gần nhất \(\mathbf{c}_j\) của nó (so
sánh \(d_j\left( {{{\bf{x}}_i},{{\bf{c}}_j}} \right)\)</p>
</li>
<li>
<p>Xếp \(\mathbf{x}_i\) vào Cluser \(j\)</p>
</li>
</ul>
</li>
<li>
<p>Với mỗi Cluster \(j=1 \cdots k\):</p>
<ul>
<li>
<p>| Điểm trung tâm mới \(\mathbf{c}_{j}-new\) là trung bình
cộng của tất cả các điểm \(\mathbf{x}_i\) đã được xếp vào
trong Cluster \(j\) từ bước trên.
|</p>
<p>\[ {{\bf{c}}<em>j} = \frac{1}{{\left| {{S_j}} \right|}}\sum\limits</em>{{{\bf{x}}_i} \in {S_j}} {{{\bf{x}}_i}}\]</p>
<p>\(S_j\) là tập các điểm dữ liệu \(\mathbf{x}_i\) của
cluster thứ \(j\) trong tập dữ liệu.</p>
</li>
</ul>
</li>
</ul>
<p>#. Kết thúc khi không có sự thay đổi từ cluster này sang cluster kia.</p>
<p>| Dựa vào công thức tính toán của hàm, chúng ta có thể đặt ra câu hỏi
là: <strong>Kiểu dữ liệu nào thì thích hợp áp dụng k-Means Clustering?</strong>.
Kiểu dữ liệu số học(numerical) hay kiểu dữ liệu phân loại
(categorical)?
| Câu trả lời là chỉ có kiểu dữ liệu số học được chấp nhận mà thôi. Bạn
thấy đấy, tất cả các bước kể trên, chúng ta đi tính khoảng cách từ 1
điểm trong tập dữ liệu \(\mathbf{x}<em>i\) đến một điểm trung tâm
\(\mathbf{c}<em>j\), đây là phương pháp tính khoảng cách hình học
Euclid chúng ta đã học từ bậc phổ thông. Đối với các tập dữ liệu chứa
các thuộc tính về Categorical, <strong>không áp dụng k-Means Clustering</strong>
được nhé!
| Trang web
\)này <a href="http://stanford.edu/class/ee103/visualizations/kmeans/kmeans.html">http://stanford.edu/class/ee103/visualizations/kmeans/kmeans.html</a>\)</em></em>
cho phép bạn nhìn thấy sự thay đổi một cách trực quan thuật toán. Bạn
nên ghé qua để có thể hiểu hơn về thuật toán.</p>
<h2 id="lựa-chọn-k">Lựa chọn K</h2>
<p>| Thuật toán k-Means yêu cầu một điều kiện tiên quyết đó là phải biết
trước chính xác giá trị của k. Đây là một bước đòi hỏi kĩ năng và kinh
nghiệm của người phân tích dữ liệu. <strong>Chọn k như thế nào là phù
hợp?</strong>. Để tìm số lượng cluster trong dữ liệu, người dùng phải chạy
thuật toán với một khoảng giá trị của k và so sánh kết quả thu được.
Cơ bản, không có phương pháp xác định giá trị chính xác nào của k,
nhưng một giá trị ước lượng đúng có thể thu được bằng cách sử dụng
phương pháp sau:
| Một đại lượng thường được sử dụng để so sánh kết quả giữa các giá trị
khác nhau của k là khoảng cách trung bình của các điểm dữ liệu
\(\mathbf{x}_i\) tới tâm của cluster \(\mathbf{c}_j\). Vì việc
tiếp tục tăng giá trị của k luôn làm giảm khoảng cách trung bình này,
và trường hợp cực trị đó là giá trị khoảng cách tiến tới 0 khi
\(k=m\) (\(m\) là số lượng điểm dữ liệu trong data). Do đó,
chúng ta không dùng đại lượng này một cách trực tiếp. Thay vào đó,
chúng ta sẽ dùng đồ thị về khoảng cách trung bình của các điểm là hàm
của k và xác định điểm gấp khúc &ldquo;elbow point&rdquo;, khi mà độ dốc của đồ
thị thay đổi đột ngột, có thể được sử dụng để xác định k.
| Một số các phương pháp khác tồn tại để xác định giá trị thích hợp của
k, đó là cross-validation, information criteria, the information
theoretic jump method, the silhouette method, và the G-means algorithm
(Xin được để nguyên văn để độc giả tiện tra cứu). Hơn nữa, việc quan
sát sự phân bố của dữ liệu trong các nhóm cung cấp cái nhìn vào việc
làm thế nào thuật toán phân chia dữ liệu đối với mỗi giá trị của k.
Việc chọn một số điểm dữ liệu ngẫu nhiên và vẽ đồ thị là cần thiết
trong đa số trường hợp.</p>

            <div id="disqus_thread"></div> 
<script>
(function() {
var d = document, s = d.createElement('script');
s.src = 'https://doannguyen.disqus.com/embed.js';
s.setAttribute('data-timestamp', +new Date());
(d.head || d.body).appendChild(s);
})();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
        </div>
        
      </div>
  </div>     
</div>


    </body><footer>
  <div class="container-fluid">
      <div class="row text-center">
          <div class="col-12">
              <h5>&copy;Doan Nguyen, 2022</h5>
              <p>nguyentrongdoan.0@gmail.com</p>
          </div>
      </div>
  </div>
</footer></html>